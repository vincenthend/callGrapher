package scanner;

import analyzer.AbstractionAnalyzer;
import analyzer.ControlFlowGraphAnalyzer;
import logger.Logger;
import model.job.DiffJobData;
import model.job.JobData;
import model.graph.ControlFlowGraph;
import model.php.PhpFunction;
import util.ControlFlowExporter;
import util.DiffJobDataLoader;
import util.FolderUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class VulnerabilityScanner {
  private static final int MAX_DEPTH = 1;
  private static final float THRESHOLD = 0.6f;
  private static final float N_THRESHOLD = 1;
  private VulnerabilityScanner(){

  }

  public static void predictVulnerable(JobData job) {
    try {
      // Read all model data
      Map<Integer, ControlFlowGraph> vulGraphList = new HashMap<>();
      Map<Integer, ControlFlowGraph> fixedGraphList = new HashMap<>();
      List<File> fileList = FolderUtil.listFilesForFolder(new File("../model/"), "cfg");
      for (File file : fileList) {
        FileInputStream inputStream = new FileInputStream(file);
        ObjectInputStream objectStream = new ObjectInputStream(inputStream);
        try {
          ControlFlowGraph cfg = (ControlFlowGraph) objectStream.readObject();
          String[] name = file.getName().split("_");
          if (name[2].contains("vuln")) {
            vulGraphList.put(Integer.valueOf(name[0]), cfg);
          } else {
            fixedGraphList.put(Integer.valueOf(name[0]), cfg);
          }
        } finally {
          objectStream.close();
          inputStream.close();
        }
      }

      // Read checked file
      ControlFlowGraph analyzedCfg = analyze(job);
      ControlFlowExporter.exportGVImage(analyzedCfg.getGraph(), job.getJobOptions().getExportPath(), "analyzed", "svg");

      // Compare checked file to model
      Map<Integer, Future<Float>> vulFuture = new HashMap<>();
      Map<Integer, Future<Float>> fixedFuture = new HashMap<>();
      ExecutorService executorService = Executors.newFixedThreadPool(4);
      Logger.info("Comparing to vulnerable");
      for (Map.Entry<Integer, ControlFlowGraph> vulGraph : vulGraphList.entrySet()) {
        vulFuture.put(vulGraph.getKey(), executorService.submit(new ScannerTask(analyzedCfg, vulGraph.getValue())));
      }

      Logger.info("Comparing to fixed");
      for (Map.Entry<Integer, ControlFlowGraph> fixedGraph : fixedGraphList.entrySet()) {
        fixedFuture.put(fixedGraph.getKey(), executorService.submit(new ScannerTask(analyzedCfg, fixedGraph.getValue())));
      }
      executorService.shutdown();

      // Get execution results
      Map<Integer, Float> vulReturn = new TreeMap<>();
      Map<Integer, Float> fixedReturn = new TreeMap<>();
      for (Map.Entry<Integer, Future<Float>> future : vulFuture.entrySet()) {
        vulReturn.put(future.getKey(), future.getValue().get());
      }

      for (Map.Entry<Integer, Future<Float>> future : fixedFuture.entrySet()) {
        fixedReturn.put(future.getKey(), future.getValue().get());
      }

      // Print Result
      Logger.info("Vul");
      Logger.info(vulReturn.toString());
      Logger.info("Fixed");
      Logger.info(fixedReturn.toString());
      int count = 0;
      for(Map.Entry<Integer, Float> entry : vulReturn.entrySet()){
        float vulVal = entry.getValue();
        float fixedVal = fixedReturn.getOrDefault(entry.getKey(), 0f);
        if(vulVal >= fixedVal && vulVal >= THRESHOLD){
          count++;
          Logger.info(entry.getKey().toString());
        }
      }
      if(count >= N_THRESHOLD){
        Logger.info("VULNERABLE");
      } else {
        Logger.info("NOT VULNERABLE");
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private static ControlFlowGraph analyze(JobData diffJobData){
    ControlFlowGraphAnalyzer analyzer = new ControlFlowGraphAnalyzer();
    analyzer.analyzeControlFlowGraph(diffJobData.getFileList());

    for (String removedFunc : diffJobData.getUnnormalizedFunction()) {
      analyzer.getProjectData().getFunctionMap().remove(removedFunc);
      analyzer.getProjectData().getNormalizedFunction(removedFunc);
    }
    analyzer.normalizeFunction(diffJobData.getShownFunction(), MAX_DEPTH);
    PhpFunction function = analyzer.getProjectData().getNormalizedFunction(diffJobData.getShownFunction());
    if (function != null) {
      ControlFlowGraph cfg = analyzer.getProjectData().getNormalizedFunction(diffJobData.getShownFunction()).getControlFlowGraph();
      AbstractionAnalyzer.analyze(cfg);
      return cfg;
    } else {
      return null;
    }
  }

  public static void generateModel(String csvFile, List<Integer> selection) throws IOException {
    List<DiffJobData> jobList = DiffJobDataLoader.loadCSV(csvFile, selection);
    Logger.info("Found " + jobList.size() + " job(s)");

    ExecutorService executorService = Executors.newFixedThreadPool(4);
    for (DiffJobData diffJobData : jobList) {
      Logger.info("Starting job with ID : " + diffJobData.getId());
      executorService.submit(new DiffTask(diffJobData, MAX_DEPTH));
    }
    executorService.shutdown();
    while (!executorService.isTerminated()) {
      // Wait
    }
  }

}
